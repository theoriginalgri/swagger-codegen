/**
 * Swagger Petstore
 * This is a sample server Petstore server.  You can find out more about Swagger at [http://swagger.io](http://swagger.io) or on [irc.freenode.net, #swagger](http://swagger.io/irc/).  For this sample, you can use the api key `special-key` to test the authorization filters.
 *
 * OpenAPI spec version: 1.0.0
 * Contact: apiteam@swagger.io
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

#include "SWGUserApi.h"
#include "JsonSerializer.h"
#include "NetworkHelper.h"

#include <QJsonObject>
#include <QJsonArray>
#include <QJsonDocument>
#include <QNetworkRequest>
#include <QNetworkReply>
#include <QUrlQuery>
#include <QHttpPart>
#include <QDebug>

namespace Swagger {

SWGUserApi::SWGUserApi(QObject *parent)
: QObject(parent)
, m_config(nullptr)
{
}

SWGUserApi::SWGUserApi(SwaggerConfig *config, QObject *parent)
: QObject(parent)
, m_config(config)
{
}

SWGUserApi::~SWGUserApi()
{
}

void SWGUserApi::setConfig(SwaggerConfig *config)
{
    m_config = config;
}

SwaggerConfig *SWGUserApi::config() const
{
    return m_config;
}

Promise<createUserReply> SWGUserApi::createUser(const SWGUser &body) {
    QUrl url(m_config->url());
    QString fullPath = url.path() + "/user";

    url.setPath(fullPath);

    QUrlQuery query(url);

    // START authentication
    // END authentication

    url.setQuery(query);

    QNetworkRequest request(url);
    request.setHeader(QNetworkRequest::ContentTypeHeader, "application/json");
    request.setAttribute(QNetworkRequest::FollowRedirectsAttribute, QVariant::fromValue(true));

    NetworkHelper helper;

    JsonSerializer serializer;
    QJsonDocument doc;
    doc.setObject(serializer.toJson(body));
    

    // Set post content
    helper.setData(doc.toJson());


    // START authentication
    // END authentication

    m_config->prepareRequest(&request);

    QNetworkReply *reply = helper.execute("POST", request, m_config->networkAccessManager());

    m_config->processReply(reply);

    Promise<createUserReply> *promise = new Promise<createUserReply>;

    connect(reply, &QNetworkReply::finished, [=](){
        JsonSerializer serializer;
        createUserReply response;
        response.httpResponse = reply;

        // TODO: Error handling
        if (reply->error() != QNetworkReply::NoError) {
            promise->reject();

            qDebug() << "HTTP error:" << reply->errorString() << reply->readAll();

            reply->deleteLater();
            delete promise;
            return;
        }

        QByteArray data = reply->readAll();

        QJsonDocument doc;
        if (!data.isEmpty()) {
            QJsonParseError error;
            doc = QJsonDocument::fromJson(data, &error);

            if (error.error != QJsonParseError::NoError) {
                promise->reject();

                qDebug() << "JSON parse error:" << error.errorString();

                reply->deleteLater();
                delete promise;
                return;
            }
        }

        int statusCode = reply->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt();
        response.statusCode = statusCode;
        switch(statusCode) {
        default: // successful operation
            {
                response.http_0 = true;
            }
            break;
        }

        promise->resolve(response);

        reply->deleteLater();
        delete promise;
    });

    return *promise;
}

Promise<createUsersWithArrayInputReply> SWGUserApi::createUsersWithArrayInput(const QList<SWGUser> &body) {
    QUrl url(m_config->url());
    QString fullPath = url.path() + "/user/createWithArray";

    url.setPath(fullPath);

    QUrlQuery query(url);

    // START authentication
    // END authentication

    url.setQuery(query);

    QNetworkRequest request(url);
    request.setHeader(QNetworkRequest::ContentTypeHeader, "application/json");
    request.setAttribute(QNetworkRequest::FollowRedirectsAttribute, QVariant::fromValue(true));

    NetworkHelper helper;

    JsonSerializer serializer;
    QJsonDocument doc;
    doc.setArray(serializer.toJson(body));


    // Set post content
    helper.setData(doc.toJson());


    // START authentication
    // END authentication

    m_config->prepareRequest(&request);

    QNetworkReply *reply = helper.execute("POST", request, m_config->networkAccessManager());

    m_config->processReply(reply);

    Promise<createUsersWithArrayInputReply> *promise = new Promise<createUsersWithArrayInputReply>;

    connect(reply, &QNetworkReply::finished, [=](){
        JsonSerializer serializer;
        createUsersWithArrayInputReply response;
        response.httpResponse = reply;

        // TODO: Error handling
        if (reply->error() != QNetworkReply::NoError) {
            promise->reject();

            qDebug() << "HTTP error:" << reply->errorString() << reply->readAll();

            reply->deleteLater();
            delete promise;
            return;
        }

        QByteArray data = reply->readAll();

        QJsonDocument doc;
        if (!data.isEmpty()) {
            QJsonParseError error;
            doc = QJsonDocument::fromJson(data, &error);

            if (error.error != QJsonParseError::NoError) {
                promise->reject();

                qDebug() << "JSON parse error:" << error.errorString();

                reply->deleteLater();
                delete promise;
                return;
            }
        }

        int statusCode = reply->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt();
        response.statusCode = statusCode;
        switch(statusCode) {
        default: // successful operation
            {
                response.http_0 = true;
            }
            break;
        }

        promise->resolve(response);

        reply->deleteLater();
        delete promise;
    });

    return *promise;
}

Promise<createUsersWithListInputReply> SWGUserApi::createUsersWithListInput(const QList<SWGUser> &body) {
    QUrl url(m_config->url());
    QString fullPath = url.path() + "/user/createWithList";

    url.setPath(fullPath);

    QUrlQuery query(url);

    // START authentication
    // END authentication

    url.setQuery(query);

    QNetworkRequest request(url);
    request.setHeader(QNetworkRequest::ContentTypeHeader, "application/json");
    request.setAttribute(QNetworkRequest::FollowRedirectsAttribute, QVariant::fromValue(true));

    NetworkHelper helper;

    JsonSerializer serializer;
    QJsonDocument doc;
    doc.setArray(serializer.toJson(body));


    // Set post content
    helper.setData(doc.toJson());


    // START authentication
    // END authentication

    m_config->prepareRequest(&request);

    QNetworkReply *reply = helper.execute("POST", request, m_config->networkAccessManager());

    m_config->processReply(reply);

    Promise<createUsersWithListInputReply> *promise = new Promise<createUsersWithListInputReply>;

    connect(reply, &QNetworkReply::finished, [=](){
        JsonSerializer serializer;
        createUsersWithListInputReply response;
        response.httpResponse = reply;

        // TODO: Error handling
        if (reply->error() != QNetworkReply::NoError) {
            promise->reject();

            qDebug() << "HTTP error:" << reply->errorString() << reply->readAll();

            reply->deleteLater();
            delete promise;
            return;
        }

        QByteArray data = reply->readAll();

        QJsonDocument doc;
        if (!data.isEmpty()) {
            QJsonParseError error;
            doc = QJsonDocument::fromJson(data, &error);

            if (error.error != QJsonParseError::NoError) {
                promise->reject();

                qDebug() << "JSON parse error:" << error.errorString();

                reply->deleteLater();
                delete promise;
                return;
            }
        }

        int statusCode = reply->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt();
        response.statusCode = statusCode;
        switch(statusCode) {
        default: // successful operation
            {
                response.http_0 = true;
            }
            break;
        }

        promise->resolve(response);

        reply->deleteLater();
        delete promise;
    });

    return *promise;
}

Promise<deleteUserReply> SWGUserApi::deleteUser(const QString &username) {
    QUrl url(m_config->url());
    QString fullPath = url.path() + "/user/{username}";

    fullPath.replace("{username}", QVariant::fromValue(username).toString());
    url.setPath(fullPath);

    QUrlQuery query(url);

    // START authentication
    // END authentication

    url.setQuery(query);

    QNetworkRequest request(url);
    request.setHeader(QNetworkRequest::ContentTypeHeader, "application/json");
    request.setAttribute(QNetworkRequest::FollowRedirectsAttribute, QVariant::fromValue(true));

    NetworkHelper helper;

    JsonSerializer serializer;
    QJsonDocument doc;


    // Set post content
    helper.setData(doc.toJson());


    // START authentication
    // END authentication

    m_config->prepareRequest(&request);

    QNetworkReply *reply = helper.execute("DELETE", request, m_config->networkAccessManager());

    m_config->processReply(reply);

    Promise<deleteUserReply> *promise = new Promise<deleteUserReply>;

    connect(reply, &QNetworkReply::finished, [=](){
        JsonSerializer serializer;
        deleteUserReply response;
        response.httpResponse = reply;

        // TODO: Error handling
        if (reply->error() != QNetworkReply::NoError) {
            promise->reject();

            qDebug() << "HTTP error:" << reply->errorString() << reply->readAll();

            reply->deleteLater();
            delete promise;
            return;
        }

        QByteArray data = reply->readAll();

        QJsonDocument doc;
        if (!data.isEmpty()) {
            QJsonParseError error;
            doc = QJsonDocument::fromJson(data, &error);

            if (error.error != QJsonParseError::NoError) {
                promise->reject();

                qDebug() << "JSON parse error:" << error.errorString();

                reply->deleteLater();
                delete promise;
                return;
            }
        }

        int statusCode = reply->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt();
        response.statusCode = statusCode;
        switch(statusCode) {
        case 400: // Invalid username supplied
            {
                response.http_400 = true;
            }
            break;
        case 404: // User not found
            {
                response.http_404 = true;
            }
            break;
        }

        promise->resolve(response);

        reply->deleteLater();
        delete promise;
    });

    return *promise;
}

Promise<getUserByNameReply> SWGUserApi::getUserByName(const QString &username) {
    QUrl url(m_config->url());
    QString fullPath = url.path() + "/user/{username}";

    fullPath.replace("{username}", QVariant::fromValue(username).toString());
    url.setPath(fullPath);

    QUrlQuery query(url);

    // START authentication
    // END authentication

    url.setQuery(query);

    QNetworkRequest request(url);
    request.setHeader(QNetworkRequest::ContentTypeHeader, "application/json");
    request.setAttribute(QNetworkRequest::FollowRedirectsAttribute, QVariant::fromValue(true));

    NetworkHelper helper;

    JsonSerializer serializer;
    QJsonDocument doc;


    // Set post content
    helper.setData(doc.toJson());


    // START authentication
    // END authentication

    m_config->prepareRequest(&request);

    QNetworkReply *reply = helper.execute("GET", request, m_config->networkAccessManager());

    m_config->processReply(reply);

    Promise<getUserByNameReply> *promise = new Promise<getUserByNameReply>;

    connect(reply, &QNetworkReply::finished, [=](){
        JsonSerializer serializer;
        getUserByNameReply response;
        response.httpResponse = reply;

        // TODO: Error handling
        if (reply->error() != QNetworkReply::NoError) {
            promise->reject();

            qDebug() << "HTTP error:" << reply->errorString() << reply->readAll();

            reply->deleteLater();
            delete promise;
            return;
        }

        QByteArray data = reply->readAll();

        QJsonDocument doc;
        if (!data.isEmpty()) {
            QJsonParseError error;
            doc = QJsonDocument::fromJson(data, &error);

            if (error.error != QJsonParseError::NoError) {
                promise->reject();

                qDebug() << "JSON parse error:" << error.errorString();

                reply->deleteLater();
                delete promise;
                return;
            }
        }

        int statusCode = reply->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt();
        response.statusCode = statusCode;
        switch(statusCode) {
        default: // successful operation
            {
                response.http_200 = QSharedPointer<SWGUser>::create();
                serializer.fromJson(response.http_200.data(), doc.object());
            }
            break;
        case 400: // Invalid username supplied
            {
                response.http_400 = true;
            }
            break;
        case 404: // User not found
            {
                response.http_404 = true;
            }
            break;
        }

        promise->resolve(response);

        reply->deleteLater();
        delete promise;
    });

    return *promise;
}

Promise<loginUserReply> SWGUserApi::loginUser(const QString &username, const QString &password) {
    QUrl url(m_config->url());
    QString fullPath = url.path() + "/user/login";

    url.setPath(fullPath);

    QUrlQuery query(url);
    query.addQueryItem("username", QVariant::fromValue(username).toString());
    query.addQueryItem("password", QVariant::fromValue(password).toString());

    // START authentication
    // END authentication

    url.setQuery(query);

    QNetworkRequest request(url);
    request.setHeader(QNetworkRequest::ContentTypeHeader, "application/json");
    request.setAttribute(QNetworkRequest::FollowRedirectsAttribute, QVariant::fromValue(true));

    NetworkHelper helper;

    JsonSerializer serializer;
    QJsonDocument doc;


    // Set post content
    helper.setData(doc.toJson());


    // START authentication
    // END authentication

    m_config->prepareRequest(&request);

    QNetworkReply *reply = helper.execute("GET", request, m_config->networkAccessManager());

    m_config->processReply(reply);

    Promise<loginUserReply> *promise = new Promise<loginUserReply>;

    connect(reply, &QNetworkReply::finished, [=](){
        JsonSerializer serializer;
        loginUserReply response;
        response.httpResponse = reply;

        // TODO: Error handling
        if (reply->error() != QNetworkReply::NoError) {
            promise->reject();

            qDebug() << "HTTP error:" << reply->errorString() << reply->readAll();

            reply->deleteLater();
            delete promise;
            return;
        }

        QByteArray data = reply->readAll();

        QJsonDocument doc;
        if (!data.isEmpty()) {
            QJsonParseError error;
            doc = QJsonDocument::fromJson(data, &error);

            if (error.error != QJsonParseError::NoError) {
                promise->reject();

                qDebug() << "JSON parse error:" << error.errorString();

                reply->deleteLater();
                delete promise;
                return;
            }
        }

        int statusCode = reply->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt();
        response.statusCode = statusCode;
        switch(statusCode) {
        default: // successful operation
            {
                response.http_200 = QSharedPointer<QString>::create();
                serializer.fromJson(response.http_200.data(), doc.object());
            }
            break;
        case 400: // Invalid username/password supplied
            {
                response.http_400 = true;
            }
            break;
        }

        promise->resolve(response);

        reply->deleteLater();
        delete promise;
    });

    return *promise;
}

Promise<logoutUserReply> SWGUserApi::logoutUser() {
    QUrl url(m_config->url());
    QString fullPath = url.path() + "/user/logout";

    url.setPath(fullPath);

    QUrlQuery query(url);

    // START authentication
    // END authentication

    url.setQuery(query);

    QNetworkRequest request(url);
    request.setHeader(QNetworkRequest::ContentTypeHeader, "application/json");
    request.setAttribute(QNetworkRequest::FollowRedirectsAttribute, QVariant::fromValue(true));

    NetworkHelper helper;

    JsonSerializer serializer;
    QJsonDocument doc;


    // Set post content
    helper.setData(doc.toJson());


    // START authentication
    // END authentication

    m_config->prepareRequest(&request);

    QNetworkReply *reply = helper.execute("GET", request, m_config->networkAccessManager());

    m_config->processReply(reply);

    Promise<logoutUserReply> *promise = new Promise<logoutUserReply>;

    connect(reply, &QNetworkReply::finished, [=](){
        JsonSerializer serializer;
        logoutUserReply response;
        response.httpResponse = reply;

        // TODO: Error handling
        if (reply->error() != QNetworkReply::NoError) {
            promise->reject();

            qDebug() << "HTTP error:" << reply->errorString() << reply->readAll();

            reply->deleteLater();
            delete promise;
            return;
        }

        QByteArray data = reply->readAll();

        QJsonDocument doc;
        if (!data.isEmpty()) {
            QJsonParseError error;
            doc = QJsonDocument::fromJson(data, &error);

            if (error.error != QJsonParseError::NoError) {
                promise->reject();

                qDebug() << "JSON parse error:" << error.errorString();

                reply->deleteLater();
                delete promise;
                return;
            }
        }

        int statusCode = reply->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt();
        response.statusCode = statusCode;
        switch(statusCode) {
        default: // successful operation
            {
                response.http_0 = true;
            }
            break;
        }

        promise->resolve(response);

        reply->deleteLater();
        delete promise;
    });

    return *promise;
}

Promise<updateUserReply> SWGUserApi::updateUser(const QString &username, const SWGUser &body) {
    QUrl url(m_config->url());
    QString fullPath = url.path() + "/user/{username}";

    fullPath.replace("{username}", QVariant::fromValue(username).toString());
    url.setPath(fullPath);

    QUrlQuery query(url);

    // START authentication
    // END authentication

    url.setQuery(query);

    QNetworkRequest request(url);
    request.setHeader(QNetworkRequest::ContentTypeHeader, "application/json");
    request.setAttribute(QNetworkRequest::FollowRedirectsAttribute, QVariant::fromValue(true));

    NetworkHelper helper;

    JsonSerializer serializer;
    QJsonDocument doc;
    doc.setObject(serializer.toJson(body));
    

    // Set post content
    helper.setData(doc.toJson());


    // START authentication
    // END authentication

    m_config->prepareRequest(&request);

    QNetworkReply *reply = helper.execute("PUT", request, m_config->networkAccessManager());

    m_config->processReply(reply);

    Promise<updateUserReply> *promise = new Promise<updateUserReply>;

    connect(reply, &QNetworkReply::finished, [=](){
        JsonSerializer serializer;
        updateUserReply response;
        response.httpResponse = reply;

        // TODO: Error handling
        if (reply->error() != QNetworkReply::NoError) {
            promise->reject();

            qDebug() << "HTTP error:" << reply->errorString() << reply->readAll();

            reply->deleteLater();
            delete promise;
            return;
        }

        QByteArray data = reply->readAll();

        QJsonDocument doc;
        if (!data.isEmpty()) {
            QJsonParseError error;
            doc = QJsonDocument::fromJson(data, &error);

            if (error.error != QJsonParseError::NoError) {
                promise->reject();

                qDebug() << "JSON parse error:" << error.errorString();

                reply->deleteLater();
                delete promise;
                return;
            }
        }

        int statusCode = reply->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt();
        response.statusCode = statusCode;
        switch(statusCode) {
        case 400: // Invalid user supplied
            {
                response.http_400 = true;
            }
            break;
        case 404: // User not found
            {
                response.http_404 = true;
            }
            break;
        }

        promise->resolve(response);

        reply->deleteLater();
        delete promise;
    });

    return *promise;
}

} /* namespace Swagger */
