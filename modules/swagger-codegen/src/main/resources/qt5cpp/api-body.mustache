{{>licenseInfo}}
#include "{{classname}}.h"
#include "JsonSerializer.h"
#include "NetworkHelper.h"

#include <QJsonObject>
#include <QJsonArray>
#include <QJsonDocument>
#include <QNetworkRequest>
#include <QNetworkReply>
#include <QUrlQuery>
#include <QHttpPart>
#include <QDebug>

{{#cppNamespaceDeclarations}}
namespace {{this}} {
{{/cppNamespaceDeclarations}}

{{classname}}::{{classname}}(QObject *parent)
: QObject(parent)
, m_config(nullptr)
{
}

{{classname}}::{{classname}}(SwaggerConfig *config, QObject *parent)
: QObject(parent)
, m_config(config)
{
}

{{classname}}::~{{classname}}()
{
}

void {{classname}}::setConfig(SwaggerConfig *config)
{
    m_config = config;
}

SwaggerConfig *{{classname}}::config() const
{
    return m_config;
}

{{#operations}}
{{#operation}}
Promise<{{nickname}}Reply> {{classname}}::{{nickname}}({{#allParams}}const {{{dataType}}} &{{paramName}}{{#hasMore}}, {{/hasMore}}{{/allParams}}) {
    JsonSerializer serializer;
    
    QUrl url(m_config->url());
    QString fullPath = url.path() + "{{path}}";

    {{#pathParams}}
    {{=<% %>=}}
    fullPath.replace("{<%baseName%>}", serializer.toJson(<%paramName%>).toString());
    <%={{ }}=%>
    {{/pathParams}}
    url.setPath(fullPath);

    QUrlQuery query(url);
    {{#queryParams}}
    {{^collectionFormat}}
    query.addQueryItem("{{paramName}}", serializer.toJson({{paramName}}).toString());
    {{/collectionFormat}}
    {{#collectionFormat}}
    query.addQueryItem("{{paramName}}", formatCollectionParameter({{paramName}}, "{{collectionFormat}}"));
    {{/collectionFormat}}
    {{/queryParams}}

    // START authentication
    {{#authMethods}}
    {{#isKeyInQuery}}
    query.addQueryItem("{{keyParamName}}", config.apiKey("{{keyParamName}}"));
    {{/isKeyInQuery}}
    {{/authMethods}}
    // END authentication

    url.setQuery(query);

    QNetworkRequest request(url);
    request.setHeader(QNetworkRequest::ContentTypeHeader, "application/json");
    request.setAttribute(QNetworkRequest::FollowRedirectsAttribute, QVariant::fromValue(true));

    NetworkHelper helper;
    {{#formParams}}
    {{^isFile}}
    helper.addVar("{{baseName}}", serializer.toJson({{paramName}}).toString());
    {{/isFile}}
    {{#isFile}}
    helper.addFile("{{baseName}}", {{paramName}});
    {{/isFile}}
    {{/formParams}}

    QJsonDocument doc;
    {{#bodyParams}}
    {{#isContainer}}
    doc.setArray(serializer.toJson({{paramName}}));
    {{/isContainer}}
    {{^isContainer}}
    doc.setObject(serializer.toJson({{paramName}}));
    {{/isContainer}}{{/bodyParams}}

    // Set post content
    helper.setData(doc.toJson(QJsonDocument::Compact));

    {{#headerParams}}
    {{#isContainer}}
    // TODO: Add container variable support for header params
    {{/isContainer}}
    {{^isContainer}}
    request.setRawHeader("{{paramName}}", QVariant::fromValue({{paramName}}).toByteArray());
    {{/isContainer}}
    {{/headerParams}}

    // START authentication
    {{#authMethods}}
    {{#isKeyInHeader}}
    request.setRawHeader("{{keyParamName}}", m_config->apiKey("{{keyParamName}}"));
    {{/isKeyInHeader}}
    {{/authMethods}}
    // END authentication

    m_config->prepareRequest(&request);

    QNetworkReply *reply = helper.execute("{{httpMethod}}", request, m_config->networkAccessManager());

    m_config->processReply(reply);

    Promise<{{nickname}}Reply> *promise = new Promise<{{nickname}}Reply>;

    connect(reply, &QNetworkReply::finished, [=](){
        int statusCode = reply->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt();

        JsonSerializer serializer;
        {{nickname}}Reply response;
        response.httpResponse = reply;
        response.statusCode = statusCode;

        // TODO: Error handling
        if (reply->error() != QNetworkReply::NoError) {
            promise->resolve(response);

            qDebug() << "HTTP error:" << reply->errorString() << reply->readAll();

            reply->deleteLater();
            delete promise;
            return;
        }

        QByteArray data = reply->readAll();

        QJsonDocument doc;
        if (!data.isEmpty()) {
            QJsonParseError error;
            doc = QJsonDocument::fromJson(data, &error);

            if (error.error != QJsonParseError::NoError) {
                promise->resolve(response);

                qDebug() << "JSON parse error:" << error.errorString();

                reply->deleteLater();
                delete promise;
                return;
            }
        }

        switch(statusCode) {
        {{#responses}}
        {{#isDefault}}
        default: // {{{message}}}
        {{/isDefault}}
        {{^isDefault}}
        case {{code}}: // {{{message}}}
        {{/isDefault}}
            {
                {{#dataType}}
                response.http_{{code}} = QSharedPointer<{{{dataType}}}>::create();
                serializer.fromJson(response.http_{{code}}.data(), doc.{{#isListContainer}}array{{/isListContainer}}{{^isListContainer}}object{{/isListContainer}}());
                {{/dataType}}
                {{^dataType}}
                response.http_{{code}} = true;
                {{/dataType}}
            }
            break;
        {{/responses}}
        }

        promise->resolve(response);

        reply->deleteLater();
        delete promise;
    });

    return *promise;
}

{{/operation}}
{{/operations}}

{{#cppNamespaceDeclarations}}
} // namespace {{this}}
{{/cppNamespaceDeclarations}}
