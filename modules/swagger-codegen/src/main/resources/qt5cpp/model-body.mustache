{{>licenseInfo}}
{{#models}}{{#model}}
#include "{{classname}}.h"
#include "{{classname}}_p.h"

#include <QDataStream>
#include <QCoreApplication>

{{#cppNamespaceDeclarations}}
namespace {{this}} {
{{/cppNamespaceDeclarations}}

{{#hasVars}}
{{classname}}::{{classname}}()
: d(new {{classname}}Data)
{
}

{{classname}}::{{classname}}(const {{classname}} &other)
: d(other.d)
{
}

{{classname}}::~{{classname}}()
{
}

{{classname}} &{{classname}}::operator =(const {{classname}} &other)
{
    d = other.d;
    return *this;
}

bool {{classname}}::operator ==(const {{classname}} &cmp) const
{
    if (d == cmp.d) {
        return true;
    }

    return (
        d->_q_properties == cmp.d->_q_properties &&
        d->setFields == cmp.d->setFields &&
        {{#vars}}
        d->{{getter}} == cmp.d->{{getter}}{{#hasMore}} &&{{/hasMore}}
        {{/vars}}
    );
}

bool {{classname}}::operator !=(const {{classname}} &cmp) const
{
    return !(*this == cmp);
}

void {{classname}}::setProperty(const QString &name, const QVariant &value)
{
    if (value.isNull()) {
        d->_q_properties.remove(name);
    } else {
        d->_q_properties.insert(name, value);
    }
}

QVariant {{classname}}::property(const QString &name) const
{
    return d->_q_properties.value(name);
}

bool {{classname}}::isSet(const QString &name) const
{
    return d->setFields.value(name, false);
}

QVariantMap {{classname}}::toMap(bool *ok) const
{
    if (ok) {
        *ok = true;
    }

    QVariantMap map(d->_q_properties);
    {{#vars}}
    map.insert("{{name}}", QVariant::fromValue(d->{{getter}}));
    {{/vars}}
    return map;
}

{{#vars}}
{{{datatype}}} {{classname}}::{{getter}}() const
{
    return d->{{getter}};
}

void {{classname}}::{{setter}}(const {{{datatype}}} &{{getter}})
{
    d->setFields.insert("{{name}}", true);
    d->{{getter}} = {{getter}};
}

{{#isContainer}}
void {{classname}}::append_{{getter}}(const {{#complexType}}{{{complexType}}}{{/complexType}}{{^complexType}}QVariant{{/complexType}} &{{getter}})
{
    d->{{getter}}.append({{getter}});
}

int {{classname}}::remove_{{getter}}(const {{#complexType}}{{{complexType}}}{{/complexType}}{{^complexType}}QVariant{{/complexType}} &{{getter}})
{
    return d->{{getter}}.removeAll({{getter}});
}
{{/isContainer}}
{{/vars}}
QDataStream &operator <<(QDataStream &out, const {{classname}} &obj)
{
    out{{#vars}} << obj.{{getter}}(){{/vars}};
    
    return out;
}

QDataStream &operator >>(QDataStream &in, {{classname}} &obj)
{
    {{#vars}}
    {{{datatype}}} {{getter}};
    in >> {{getter}};
    {{/vars}}
    
    {{#vars}}
    obj.{{setter}}({{getter}});
    {{/vars}}
    
    return in;
}

QDebug operator <<(QDebug stream, const {{classname}} &obj)
{
    QDebugStateSaver saver(stream);
    stream.nospace()
        << "{{classname}} { "
        {{#vars}}
        << "{{getter}}: " << obj.{{getter}}(){{#hasMore}} << ", "{{/hasMore}}
        {{/vars}}
        << " }";

    return stream;
}

static void registerConverters()
{
    QMetaType::registerConverter(&{{classname}}::toMap);

    // Also register without namespaces
    qRegisterMetaType<{{classname}}>("{{classname}}");

    // Register stream operators
    qRegisterMetaTypeStreamOperators<{{classname}}>("{{classname}}");
}

Q_COREAPP_STARTUP_FUNCTION(registerConverters)
{{/hasVars}}

{{#cppNamespaceDeclarations}}
} // namespace {{this}}
{{/cppNamespaceDeclarations}}

{{/model}}
{{/models}}
