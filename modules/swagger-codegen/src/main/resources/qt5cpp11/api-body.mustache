{{>licenseInfo}}
#include "{{classname}}.h"
#include "{{prefix}}Helpers.h"
#include "{{prefix}}ModelFactory.h"

#include <QJsonArray>
#include <QJsonDocument>

namespace Swagger {

static QHash<QString, QLatin1Char> collectionFormatDelimiters {
    { "csv", QLatin1Char(',') },
    { "tsv", QLatin1Char('\t') },
    { "ssv", QLatin1Char(' ') },
    { "pipes", QLatin1Char('|') },
};

template <typename T>
static QString formatCollectionParameter(const QList<T> &list, const QString &collectionFormat) {
    const QString delimiter = collectionFormatDelimiters.value(collectionFormat);

    QString value;
    QTextStream s(&value);

    QListIterator<T> iter(list);
    while (iter.hasNext()) {
        s << iter.next();

        if (iter.hasNext()) {
            s << delimiter;
        }
    }

    return value;
}

{{classname}}::{{classname}}(QObject *parent)
: QObject(parent)
, m_networkAccessManager(nullptr)
{
}

{{classname}}::{{classname}}(const QUrl &url, QObject *parent)
: QObject(parent)
, m_url(url)
, m_networkAccessManager(nullptr)
{
}

{{classname}}::~{{classname}}()
{
}

{{#operations}}
{{#operation}}
void {{classname}}::{{nickname}}({{#allParams}}{{{dataType}}} {{paramName}}{{#hasMore}}, {{/hasMore}}{{/allParams}}) {
    QUrl url(m_url);
    QString fullPath = url.path() + "{{path}}";

    {{#pathParams}}
    {{=<% %>=}}
    fullPath.replace("{<%paramName%>}", QVariant::fromValue(<%paramName%>).toString());
    <%={{ }}=%>
    {{/pathParams}}

    QUrlQuery query(url);
    {{#queryParams}}
    {{^collectionFormat}}
    query.addQueryParam("{{paramName}}", QVariant::fromValue({{paramName}}).toString());
    {{/collectionFormat}}
    {{#collectionFormat}}

    query.addQueryParam("{{paramName}}", formatCollectionParameter({{paramName}}, {{collectionFormat}}));

    if ({{{paramName}}}->size() > 0) {
      if (QString("{{collectionFormat}}").indexOf("multi") == 0) {
        foreach({{{baseType}}} t, *{{paramName}}) {
          if (fullPath.indexOf("?") > 0)
            fullPath.append("&");
          else
            fullPath.append("?");
          fullPath.append("{{{paramName}}}=").append(stringValue(t));
        }
      }
      else if (QString("{{collectionFormat}}").indexOf("ssv") == 0) {
        if (fullPath.indexOf("?") > 0)
          fullPath.append("&");
        else
          fullPath.append("?");
        fullPath.append("{{paramName}}=");
        qint32 count = 0;
        foreach({{{baseType}}} t, *{{paramName}}) {
          if (count > 0) {
            fullPath.append(" ");
          }
          fullPath.append(stringValue(t));
        }
      }
      else if (QString("{{collectionFormat}}").indexOf("tsv") == 0) {
        if (fullPath.indexOf("?") > 0)
          fullPath.append("&");
        else
          fullPath.append("?");
        fullPath.append("{{paramName}}=");
        qint32 count = 0;
        foreach({{{baseType}}} t, *{{paramName}}) {
          if (count > 0) {
            fullPath.append("\t");
          }
          fullPath.append(stringValue(t));
        }
      }
    }

    {{/collectionFormat}}
    {{/queryParams}}
    url.setQuery(query);

    QNetworkRequest request(url);

    HttpRequestWorker *worker = new HttpRequestWorker();
    HttpRequestInput input(fullPath, "{{httpMethod}}");

    {{#formParams}}if ({{paramName}} != NULL) {
        {{^isFile}}input.add_var("{{paramName}}", *{{paramName}});{{/isFile}}{{#isFile}}input.add_file("{{paramName}}", (*{{paramName}}).local_filename, (*{{paramName}}).request_filename, (*{{paramName}}).mime_type);{{/isFile}}
    }
    {{/formParams}}

    {{#bodyParams}}
    {{#isContainer}}
    QJsonArray* {{paramName}}Array = new QJsonArray();
    toJsonArray((QList<void*>*){{paramName}}, {{paramName}}Array, QString("body"), QString("SWGUser*"));

    QJsonDocument doc(*{{paramName}}Array);
    QByteArray bytes = doc.toJson();

    input.request_body.append(bytes);
    {{/isContainer}}
    {{^isContainer}}
    QString output = {{paramName}}.asJson();
    input.request_body.append(output);
    {{/isContainer}}{{/bodyParams}}

    {{#headerParams}}
    {{#isContainer}}
    // TODO: Add container variable support for header params
    {{/isContainer}}
    {{^isContainer}}
    request.addRawHeader("{{paramName}}", QVariant::fromValue({{paramName}}).toByteArray());
    {{/isContainer}}
    {{/headerParams}}

    connect(worker,
            &HttpRequestWorker::on_execution_finished,
            this,
            &{{classname}}::{{nickname}}Callback);

    worker->execute(&input);
}

void {{classname}}::{{nickname}}Callback(HttpRequestWorker * worker) {
    QString msg;
    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }

    {{#returnType}}{{#isListContainer}}
    {{{returnType}}} output = {{{defaultResponse}}};
    QString json(worker->response);
    QByteArray array (json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();

    foreach(QJsonValue obj, jsonArray) {
        {{{returnBaseType}}}* o = new {{returnBaseType}}();
        QJsonObject jv = obj.toObject();
        QJsonObject * ptr = (QJsonObject*)&jv;
        o->fromJsonObject(*ptr);
        output->append(o);
    }
    {{/isListContainer}}

    {{^isListContainer}}{{#returnTypeIsPrimitive}}
    {{{returnType}}} output;  // TODO add primitive output support
    {{/returnTypeIsPrimitive}}
    {{#isMapContainer}} 
    {{{returnType}}} output = {{{defaultResponse}}};

    QString json(worker->response);
    QByteArray array (json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject obj = doc.object();

    foreach(QString key, obj.keys()) {
        qint32* val;
        setValue(&val, obj[key], "{{returnBaseType}}", "");
        output->insert(key, *val);
    }


    {{/isMapContainer}}
    {{^isMapContainer}}
    {{^returnTypeIsPrimitive}}QString json(worker->response);
    {{{returnType}}} output = static_cast<{{{returnType}}}>(create(json, QString("{{{returnBaseType}}}")));
    {{/returnTypeIsPrimitive}}
    {{/isMapContainer}}
    {{/isListContainer}}{{/returnType}}

    worker->deleteLater();

    {{#returnType}}emit {{nickname}}Signal(output);{{/returnType}}
    {{^returnType}}emit {{nickname}}Signal();{{/returnType}}
}
{{/operation}}
{{/operations}}
} /* namespace Swagger */
