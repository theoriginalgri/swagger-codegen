{{>licenseInfo}}
#include "{{classname}}.h"

#include <QJsonArray>
#include <QJsonDocument>

#ifdef QT_QML_LIB
#include <QtQml>
#endif // QT_QML_LIB

namespace Swagger {

static QHash<QString, QChar> collectionFormatDelimiters {
    { "csv", QLatin1Char(',') },
    { "tsv", QLatin1Char('\t') },
    { "ssv", QLatin1Char(' ') },
    { "pipes", QLatin1Char('|') },
};

template <typename T>
static QString formatCollectionParameter(const QList<T> &list, const QString &collectionFormat) {
    const QChar delimiter = collectionFormatDelimiters.value(collectionFormat);

    QString value;
    QTextStream s(&value);

    QListIterator<T> iter(list);
    while (iter.hasNext()) {
        s << iter.next();

        if (iter.hasNext()) {
            s << delimiter;
        }
    }

    return value;
}

{{classname}}::{{classname}}(QObject *parent)
: QObject(parent)
, m_networkAccessManager(nullptr)
{
}

{{classname}}::{{classname}}(const QUrl &url, QObject *parent)
: QObject(parent)
, m_url(url)
, m_networkAccessManager(nullptr)
{
}

{{classname}}::~{{classname}}()
{
}

void {{classname}}::setUrl(const QUrl &url)
{
    if (m_url == url) {
        return;
    }

    m_url = url;

    emit urlChanged(url);
}

QUrl {{classname}}::url() const
{
    return m_url;
}

void {{classname}}::setNetworkAccessManager(QNetworkAccessManager *networkAccessManager)
{
    if (m_networkAccessManager == networkAccessManager) {
        return;
    }

    if (m_networkAccessManager && m_networkAccessManager->parent() == this) {
        m_networkAccessManager->deleteLater();
    }

    m_networkAccessManager = networkAccessManager;
}

QNetworkAccessManager *{{classname}}::networkAccessManager()
{
    if (!m_networkAccessManager) {
#ifdef QT_QML_LIB
        QQmlEngine *engine = qmlEngine(this);
        if (engine) {
            m_networkAccessManager = engine->networkAccessManager();
        }
#endif // QT_QML_LIB

        if (!m_networkAccessManager) {
            m_networkAccessManager = new QNetworkAccessManager(this);
        }
    }

    return m_networkAccessManager;
}

{{#operations}}
{{#operation}}
void {{classname}}::{{nickname}}({{#allParams}}{{{dataType}}} {{#vendorExtensions.x-codegen-isPointer}}*{{/vendorExtensions.x-codegen-isPointer}}{{paramName}}{{#hasMore}}, {{/hasMore}}{{/allParams}}) {
    QUrl url(m_url);
    QString fullPath = url.path() + "{{path}}";

    {{#pathParams}}
    {{=<% %>=}}
    fullPath.replace("{<%paramName%>}", QVariant::fromValue(<%paramName%>).toString());
    <%={{ }}=%>
    {{/pathParams}}

    QUrlQuery query(url);
    {{#queryParams}}
    {{^collectionFormat}}
    query.addQueryItem("{{paramName}}", QVariant::fromValue({{paramName}}).toString());
    {{/collectionFormat}}
    {{#collectionFormat}}
    query.addQueryItem("{{paramName}}", formatCollectionParameter({{paramName}}, "{{collectionFormat}}"));
    {{/collectionFormat}}
    {{/queryParams}}
    url.setQuery(query);

    QNetworkRequest request(url);
    request.setAttribute(QNetworkRequest::FollowRedirectsAttribute, QVariant::fromValue(true));

    QByteArray output;

    /*
    HttpRequestWorker *worker = new HttpRequestWorker();
    HttpRequestInput input(fullPath, "{{httpMethod}}");

    {{#formParams}}if ({{paramName}} != NULL) {
        {{^isFile}}input.add_var("{{paramName}}", *{{paramName}});{{/isFile}}{{#isFile}}input.add_file("{{paramName}}", (*{{paramName}}).local_filename, (*{{paramName}}).request_filename, (*{{paramName}}).mime_type);{{/isFile}}
    }
    {{/formParams}}

    {{#bodyParams}}
    {{#isContainer}}
    QJsonArray* {{paramName}}Array = new QJsonArray();
    toJsonArray((QList<void*>*){{paramName}}, {{paramName}}Array, QString("body"), QString("SWGUser*"));

    QJsonDocument doc(*{{paramName}}Array);
    QByteArray bytes = doc.toJson();

    input.request_body.append(bytes);
    {{/isContainer}}
    {{^isContainer}}
    QString output = {{paramName}}.asJson();
    input.request_body.append(output);
    {{/isContainer}}{{/bodyParams}}
    */

    {{#headerParams}}
    {{#isContainer}}
    // TODO: Add container variable support for header params
    {{/isContainer}}
    {{^isContainer}}
    request.setRawHeader("{{paramName}}", QVariant::fromValue({{paramName}}).toByteArray());
    {{/isContainer}}
    {{/headerParams}}

    {{#vendorExtensions.x-codegen-http-post}}
    QNetworkReply *reply = networkAccessManager()->post(request, output);
    {{/vendorExtensions.x-codegen-http-post}}
    {{#vendorExtensions.x-codegen-http-put}}
    QNetworkReply *reply = networkAccessManager()->put(request, output);
    {{/vendorExtensions.x-codegen-http-put}}
    {{#vendorExtensions.x-codegen-http-get}}
    QNetworkReply *reply = networkAccessManager()->get(request);
    {{/vendorExtensions.x-codegen-http-get}}
    {{#vendorExtensions.x-codegen-http-head}}
    QNetworkReply *reply = networkAccessManager()->head(request);
    {{/vendorExtensions.x-codegen-http-head}}
    {{#vendorExtensions.x-codegen-http-delete}}
    QNetworkReply *reply = networkAccessManager()->deleteResource(request);
    {{/vendorExtensions.x-codegen-http-delete}}

    connect(reply, &QNetworkReply::finished, [this, reply]() {
        {{#returnType}}
        {{{returnType}}} output;

        emit {{nickname}}Signal(reply->error(), reply->errorString(), output);
        {{/returnType}}
        {{^returnType}}emit {{nickname}}Signal(reply->error(), reply->errorString());{{/returnType}}

        reply->deleteLater();
    });
}

/*
void {{classname}}::{{nickname}}Callback(HttpRequestWorker * worker) {
    QString msg;
    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }

    {{#returnType}}{{#isListContainer}}
    {{{returnType}}} output = {{{defaultResponse}}};
    QString json(worker->response);
    QByteArray array (json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();

    foreach(QJsonValue obj, jsonArray) {
        {{{returnBaseType}}}* o = new {{returnBaseType}}();
        QJsonObject jv = obj.toObject();
        QJsonObject * ptr = (QJsonObject*)&jv;
        o->fromJsonObject(*ptr);
        output->append(o);
    }
    {{/isListContainer}}

    {{^isListContainer}}{{#returnTypeIsPrimitive}}
    {{{returnType}}} output;  // TODO add primitive output support
    {{/returnTypeIsPrimitive}}
    {{#isMapContainer}} 
    {{{returnType}}} output = {{{defaultResponse}}};

    QString json(worker->response);
    QByteArray array (json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject obj = doc.object();

    foreach(QString key, obj.keys()) {
        qint32* val;
        setValue(&val, obj[key], "{{returnBaseType}}", "");
        output->insert(key, *val);
    }


    {{/isMapContainer}}
    {{^isMapContainer}}
    {{^returnTypeIsPrimitive}}QString json(worker->response);
    {{{returnType}}} output = static_cast<{{{returnType}}}>(create(json, QString("{{{returnBaseType}}}")));
    {{/returnTypeIsPrimitive}}
    {{/isMapContainer}}
    {{/isListContainer}}{{/returnType}}

    worker->deleteLater();

    {{#returnType}}emit {{nickname}}Signal(output);{{/returnType}}
    {{^returnType}}emit {{nickname}}Signal();{{/returnType}}
}
*/
{{/operation}}
{{/operations}}
} /* namespace Swagger */
